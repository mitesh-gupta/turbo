// Code generated by capnpc-go. DO NOT EDIT.

package capnp

import (
	capnp "capnproto.org/go/capnp/v3"
	text "capnproto.org/go/capnp/v3/encoding/text"
	schemas "capnproto.org/go/capnp/v3/schemas"
)

type TaskHashable capnp.Struct

// TaskHashable_TypeID is the unique identifier for the type TaskHashable.
const TaskHashable_TypeID = 0xe1f09ceb4ef5e479

func NewTaskHashable(s *capnp.Segment) (TaskHashable, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 12})
	return TaskHashable(st), err
}

func NewRootTaskHashable(s *capnp.Segment) (TaskHashable, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 12})
	return TaskHashable(st), err
}

func ReadRootTaskHashable(msg *capnp.Message) (TaskHashable, error) {
	root, err := msg.Root()
	return TaskHashable(root.Struct()), err
}

func (s TaskHashable) String() string {
	str, _ := text.Marshal(0xe1f09ceb4ef5e479, capnp.Struct(s))
	return str
}

func (s TaskHashable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TaskHashable) DecodeFromPtr(p capnp.Ptr) TaskHashable {
	return TaskHashable(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TaskHashable) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TaskHashable) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TaskHashable) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TaskHashable) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TaskHashable) GlobalHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s TaskHashable) HasGlobalHash() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TaskHashable) GlobalHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s TaskHashable) SetGlobalHash(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s TaskHashable) TaskDependencyHashes() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasTaskDependencyHashes() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TaskHashable) SetTaskDependencyHashes(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewTaskDependencyHashes sets the taskDependencyHashes field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewTaskDependencyHashes(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s TaskHashable) PackageDir() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s TaskHashable) HasPackageDir() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s TaskHashable) PackageDirBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s TaskHashable) SetPackageDir(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s TaskHashable) HashOfFiles() (string, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.Text(), err
}

func (s TaskHashable) HasHashOfFiles() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s TaskHashable) HashOfFilesBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return p.TextBytes(), err
}

func (s TaskHashable) SetHashOfFiles(v string) error {
	return capnp.Struct(s).SetText(3, v)
}

func (s TaskHashable) ExternalDepsHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.Text(), err
}

func (s TaskHashable) HasExternalDepsHash() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s TaskHashable) ExternalDepsHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return p.TextBytes(), err
}

func (s TaskHashable) SetExternalDepsHash(v string) error {
	return capnp.Struct(s).SetText(4, v)
}

func (s TaskHashable) Task() (string, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.Text(), err
}

func (s TaskHashable) HasTask() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s TaskHashable) TaskBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return p.TextBytes(), err
}

func (s TaskHashable) SetTask(v string) error {
	return capnp.Struct(s).SetText(5, v)
}

func (s TaskHashable) Outputs() (TaskOutputs, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return TaskOutputs(p.Struct()), err
}

func (s TaskHashable) HasOutputs() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s TaskHashable) SetOutputs(v TaskOutputs) error {
	return capnp.Struct(s).SetPtr(6, capnp.Struct(v).ToPtr())
}

// NewOutputs sets the outputs field to a newly
// allocated TaskOutputs struct, preferring placement in s's segment.
func (s TaskHashable) NewOutputs() (TaskOutputs, error) {
	ss, err := NewTaskOutputs(capnp.Struct(s).Segment())
	if err != nil {
		return TaskOutputs{}, err
	}
	err = capnp.Struct(s).SetPtr(6, capnp.Struct(ss).ToPtr())
	return ss, err
}

func (s TaskHashable) PassThruArgs() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(7)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasPassThruArgs() bool {
	return capnp.Struct(s).HasPtr(7)
}

func (s TaskHashable) SetPassThruArgs(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(7, v.ToPtr())
}

// NewPassThruArgs sets the passThruArgs field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewPassThruArgs(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(7, l.ToPtr())
	return l, err
}
func (s TaskHashable) Env() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(8)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasEnv() bool {
	return capnp.Struct(s).HasPtr(8)
}

func (s TaskHashable) SetEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(8, v.ToPtr())
}

// NewEnv sets the env field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(8, l.ToPtr())
	return l, err
}
func (s TaskHashable) ResolvedEnvVars() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(9)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasResolvedEnvVars() bool {
	return capnp.Struct(s).HasPtr(9)
}

func (s TaskHashable) SetResolvedEnvVars(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(9, v.ToPtr())
}

// NewResolvedEnvVars sets the resolvedEnvVars field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewResolvedEnvVars(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(9, l.ToPtr())
	return l, err
}
func (s TaskHashable) PassThruEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(10)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasPassThruEnv() bool {
	return capnp.Struct(s).HasPtr(10)
}

func (s TaskHashable) SetPassThruEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(10, v.ToPtr())
}

// NewPassThruEnv sets the passThruEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewPassThruEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(10, l.ToPtr())
	return l, err
}
func (s TaskHashable) EnvMode() TaskHashable_EnvMode {
	return TaskHashable_EnvMode(capnp.Struct(s).Uint16(0))
}

func (s TaskHashable) SetEnvMode(v TaskHashable_EnvMode) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s TaskHashable) DotEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(11)
	return capnp.TextList(p.List()), err
}

func (s TaskHashable) HasDotEnv() bool {
	return capnp.Struct(s).HasPtr(11)
}

func (s TaskHashable) SetDotEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(11, v.ToPtr())
}

// NewDotEnv sets the dotEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskHashable) NewDotEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(11, l.ToPtr())
	return l, err
}

// TaskHashable_List is a list of TaskHashable.
type TaskHashable_List = capnp.StructList[TaskHashable]

// NewTaskHashable creates a new list of TaskHashable.
func NewTaskHashable_List(s *capnp.Segment, sz int32) (TaskHashable_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 12}, sz)
	return capnp.StructList[TaskHashable](l), err
}

// TaskHashable_Future is a wrapper for a TaskHashable promised by a client call.
type TaskHashable_Future struct{ *capnp.Future }

func (f TaskHashable_Future) Struct() (TaskHashable, error) {
	p, err := f.Future.Ptr()
	return TaskHashable(p.Struct()), err
}
func (p TaskHashable_Future) Outputs() TaskOutputs_Future {
	return TaskOutputs_Future{Future: p.Future.Field(6, nil)}
}

type TaskHashable_EnvMode uint16

// TaskHashable_EnvMode_TypeID is the unique identifier for the type TaskHashable_EnvMode.
const TaskHashable_EnvMode_TypeID = 0x8dc08a1d29f69b16

// Values of TaskHashable_EnvMode.
const (
	TaskHashable_EnvMode_infer  TaskHashable_EnvMode = 0
	TaskHashable_EnvMode_loose  TaskHashable_EnvMode = 1
	TaskHashable_EnvMode_strict TaskHashable_EnvMode = 2
)

// String returns the enum's constant name.
func (c TaskHashable_EnvMode) String() string {
	switch c {
	case TaskHashable_EnvMode_infer:
		return "infer"
	case TaskHashable_EnvMode_loose:
		return "loose"
	case TaskHashable_EnvMode_strict:
		return "strict"

	default:
		return ""
	}
}

// TaskHashable_EnvModeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func TaskHashable_EnvModeFromString(c string) TaskHashable_EnvMode {
	switch c {
	case "infer":
		return TaskHashable_EnvMode_infer
	case "loose":
		return TaskHashable_EnvMode_loose
	case "strict":
		return TaskHashable_EnvMode_strict

	default:
		return 0
	}
}

type TaskHashable_EnvMode_List = capnp.EnumList[TaskHashable_EnvMode]

func NewTaskHashable_EnvMode_List(s *capnp.Segment, sz int32) (TaskHashable_EnvMode_List, error) {
	return capnp.NewEnumList[TaskHashable_EnvMode](s, sz)
}

type TaskOutputs capnp.Struct

// TaskOutputs_TypeID is the unique identifier for the type TaskOutputs.
const TaskOutputs_TypeID = 0xd58300fce8aba267

func NewTaskOutputs(s *capnp.Segment) (TaskOutputs, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TaskOutputs(st), err
}

func NewRootTaskOutputs(s *capnp.Segment) (TaskOutputs, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return TaskOutputs(st), err
}

func ReadRootTaskOutputs(msg *capnp.Message) (TaskOutputs, error) {
	root, err := msg.Root()
	return TaskOutputs(root.Struct()), err
}

func (s TaskOutputs) String() string {
	str, _ := text.Marshal(0xd58300fce8aba267, capnp.Struct(s))
	return str
}

func (s TaskOutputs) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (TaskOutputs) DecodeFromPtr(p capnp.Ptr) TaskOutputs {
	return TaskOutputs(capnp.Struct{}.DecodeFromPtr(p))
}

func (s TaskOutputs) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s TaskOutputs) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s TaskOutputs) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s TaskOutputs) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s TaskOutputs) Inclusions() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return capnp.TextList(p.List()), err
}

func (s TaskOutputs) HasInclusions() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s TaskOutputs) SetInclusions(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewInclusions sets the inclusions field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskOutputs) NewInclusions(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}
func (s TaskOutputs) Exclusions() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return capnp.TextList(p.List()), err
}

func (s TaskOutputs) HasExclusions() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s TaskOutputs) SetExclusions(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewExclusions sets the exclusions field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s TaskOutputs) NewExclusions(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}

// TaskOutputs_List is a list of TaskOutputs.
type TaskOutputs_List = capnp.StructList[TaskOutputs]

// NewTaskOutputs creates a new list of TaskOutputs.
func NewTaskOutputs_List(s *capnp.Segment, sz int32) (TaskOutputs_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[TaskOutputs](l), err
}

// TaskOutputs_Future is a wrapper for a TaskOutputs promised by a client call.
type TaskOutputs_Future struct{ *capnp.Future }

func (f TaskOutputs_Future) Struct() (TaskOutputs, error) {
	p, err := f.Future.Ptr()
	return TaskOutputs(p.Struct()), err
}

type GlobalHashable capnp.Struct

// GlobalHashable_TypeID is the unique identifier for the type GlobalHashable.
const GlobalHashable_TypeID = 0xea0b3688577e30b4

func NewGlobalHashable(s *capnp.Segment) (GlobalHashable, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7})
	return GlobalHashable(st), err
}

func NewRootGlobalHashable(s *capnp.Segment) (GlobalHashable, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7})
	return GlobalHashable(st), err
}

func ReadRootGlobalHashable(msg *capnp.Message) (GlobalHashable, error) {
	root, err := msg.Root()
	return GlobalHashable(root.Struct()), err
}

func (s GlobalHashable) String() string {
	str, _ := text.Marshal(0xea0b3688577e30b4, capnp.Struct(s))
	return str
}

func (s GlobalHashable) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GlobalHashable) DecodeFromPtr(p capnp.Ptr) GlobalHashable {
	return GlobalHashable(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GlobalHashable) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GlobalHashable) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GlobalHashable) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GlobalHashable) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GlobalHashable) GlobalCacheKey() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s GlobalHashable) HasGlobalCacheKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s GlobalHashable) GlobalCacheKeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s GlobalHashable) SetGlobalCacheKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s GlobalHashable) GlobalFileHashMap() (GlobalHashable_Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return GlobalHashable_Entry_List(p.List()), err
}

func (s GlobalHashable) HasGlobalFileHashMap() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s GlobalHashable) SetGlobalFileHashMap(v GlobalHashable_Entry_List) error {
	return capnp.Struct(s).SetPtr(1, v.ToPtr())
}

// NewGlobalFileHashMap sets the globalFileHashMap field to a newly
// allocated GlobalHashable_Entry_List, preferring placement in s's segment.
func (s GlobalHashable) NewGlobalFileHashMap(n int32) (GlobalHashable_Entry_List, error) {
	l, err := NewGlobalHashable_Entry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return GlobalHashable_Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(1, l.ToPtr())
	return l, err
}
func (s GlobalHashable) RootExternalDepsHash() (string, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.Text(), err
}

func (s GlobalHashable) HasRootExternalDepsHash() bool {
	return capnp.Struct(s).HasPtr(2)
}

func (s GlobalHashable) RootExternalDepsHashBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(2)
	return p.TextBytes(), err
}

func (s GlobalHashable) SetRootExternalDepsHash(v string) error {
	return capnp.Struct(s).SetText(2, v)
}

func (s GlobalHashable) Env() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(3)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasEnv() bool {
	return capnp.Struct(s).HasPtr(3)
}

func (s GlobalHashable) SetEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(3, v.ToPtr())
}

// NewEnv sets the env field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(3, l.ToPtr())
	return l, err
}
func (s GlobalHashable) ResolvedEnvVars() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(4)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasResolvedEnvVars() bool {
	return capnp.Struct(s).HasPtr(4)
}

func (s GlobalHashable) SetResolvedEnvVars(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(4, v.ToPtr())
}

// NewResolvedEnvVars sets the resolvedEnvVars field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewResolvedEnvVars(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(4, l.ToPtr())
	return l, err
}
func (s GlobalHashable) PassThroughEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(5)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasPassThroughEnv() bool {
	return capnp.Struct(s).HasPtr(5)
}

func (s GlobalHashable) SetPassThroughEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(5, v.ToPtr())
}

// NewPassThroughEnv sets the passThroughEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewPassThroughEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(5, l.ToPtr())
	return l, err
}
func (s GlobalHashable) EnvMode() GlobalHashable_EnvMode {
	return GlobalHashable_EnvMode(capnp.Struct(s).Uint16(0))
}

func (s GlobalHashable) SetEnvMode(v GlobalHashable_EnvMode) {
	capnp.Struct(s).SetUint16(0, uint16(v))
}

func (s GlobalHashable) FrameworkInference() bool {
	return capnp.Struct(s).Bit(16)
}

func (s GlobalHashable) SetFrameworkInference(v bool) {
	capnp.Struct(s).SetBit(16, v)
}

func (s GlobalHashable) DotEnv() (capnp.TextList, error) {
	p, err := capnp.Struct(s).Ptr(6)
	return capnp.TextList(p.List()), err
}

func (s GlobalHashable) HasDotEnv() bool {
	return capnp.Struct(s).HasPtr(6)
}

func (s GlobalHashable) SetDotEnv(v capnp.TextList) error {
	return capnp.Struct(s).SetPtr(6, v.ToPtr())
}

// NewDotEnv sets the dotEnv field to a newly
// allocated capnp.TextList, preferring placement in s's segment.
func (s GlobalHashable) NewDotEnv(n int32) (capnp.TextList, error) {
	l, err := capnp.NewTextList(capnp.Struct(s).Segment(), n)
	if err != nil {
		return capnp.TextList{}, err
	}
	err = capnp.Struct(s).SetPtr(6, l.ToPtr())
	return l, err
}

// GlobalHashable_List is a list of GlobalHashable.
type GlobalHashable_List = capnp.StructList[GlobalHashable]

// NewGlobalHashable creates a new list of GlobalHashable.
func NewGlobalHashable_List(s *capnp.Segment, sz int32) (GlobalHashable_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 7}, sz)
	return capnp.StructList[GlobalHashable](l), err
}

// GlobalHashable_Future is a wrapper for a GlobalHashable promised by a client call.
type GlobalHashable_Future struct{ *capnp.Future }

func (f GlobalHashable_Future) Struct() (GlobalHashable, error) {
	p, err := f.Future.Ptr()
	return GlobalHashable(p.Struct()), err
}

type GlobalHashable_EnvMode uint16

// GlobalHashable_EnvMode_TypeID is the unique identifier for the type GlobalHashable_EnvMode.
const GlobalHashable_EnvMode_TypeID = 0xab4200df8263c5d4

// Values of GlobalHashable_EnvMode.
const (
	GlobalHashable_EnvMode_infer  GlobalHashable_EnvMode = 0
	GlobalHashable_EnvMode_loose  GlobalHashable_EnvMode = 1
	GlobalHashable_EnvMode_strict GlobalHashable_EnvMode = 2
)

// String returns the enum's constant name.
func (c GlobalHashable_EnvMode) String() string {
	switch c {
	case GlobalHashable_EnvMode_infer:
		return "infer"
	case GlobalHashable_EnvMode_loose:
		return "loose"
	case GlobalHashable_EnvMode_strict:
		return "strict"

	default:
		return ""
	}
}

// GlobalHashable_EnvModeFromString returns the enum value with a name,
// or the zero value if there's no such value.
func GlobalHashable_EnvModeFromString(c string) GlobalHashable_EnvMode {
	switch c {
	case "infer":
		return GlobalHashable_EnvMode_infer
	case "loose":
		return GlobalHashable_EnvMode_loose
	case "strict":
		return GlobalHashable_EnvMode_strict

	default:
		return 0
	}
}

type GlobalHashable_EnvMode_List = capnp.EnumList[GlobalHashable_EnvMode]

func NewGlobalHashable_EnvMode_List(s *capnp.Segment, sz int32) (GlobalHashable_EnvMode_List, error) {
	return capnp.NewEnumList[GlobalHashable_EnvMode](s, sz)
}

type GlobalHashable_Entry capnp.Struct

// GlobalHashable_Entry_TypeID is the unique identifier for the type GlobalHashable_Entry.
const GlobalHashable_Entry_TypeID = 0xdd6c3d394436cf49

func NewGlobalHashable_Entry(s *capnp.Segment) (GlobalHashable_Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GlobalHashable_Entry(st), err
}

func NewRootGlobalHashable_Entry(s *capnp.Segment) (GlobalHashable_Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return GlobalHashable_Entry(st), err
}

func ReadRootGlobalHashable_Entry(msg *capnp.Message) (GlobalHashable_Entry, error) {
	root, err := msg.Root()
	return GlobalHashable_Entry(root.Struct()), err
}

func (s GlobalHashable_Entry) String() string {
	str, _ := text.Marshal(0xdd6c3d394436cf49, capnp.Struct(s))
	return str
}

func (s GlobalHashable_Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (GlobalHashable_Entry) DecodeFromPtr(p capnp.Ptr) GlobalHashable_Entry {
	return GlobalHashable_Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s GlobalHashable_Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s GlobalHashable_Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s GlobalHashable_Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s GlobalHashable_Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s GlobalHashable_Entry) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s GlobalHashable_Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s GlobalHashable_Entry) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s GlobalHashable_Entry) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s GlobalHashable_Entry) Value() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s GlobalHashable_Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s GlobalHashable_Entry) ValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s GlobalHashable_Entry) SetValue(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// GlobalHashable_Entry_List is a list of GlobalHashable_Entry.
type GlobalHashable_Entry_List = capnp.StructList[GlobalHashable_Entry]

// NewGlobalHashable_Entry creates a new list of GlobalHashable_Entry.
func NewGlobalHashable_Entry_List(s *capnp.Segment, sz int32) (GlobalHashable_Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[GlobalHashable_Entry](l), err
}

// GlobalHashable_Entry_Future is a wrapper for a GlobalHashable_Entry promised by a client call.
type GlobalHashable_Entry_Future struct{ *capnp.Future }

func (f GlobalHashable_Entry_Future) Struct() (GlobalHashable_Entry, error) {
	p, err := f.Future.Ptr()
	return GlobalHashable_Entry(p.Struct()), err
}

type LockFilePackages capnp.Struct

// LockFilePackages_TypeID is the unique identifier for the type LockFilePackages.
const LockFilePackages_TypeID = 0xb470b49a14912305

func NewLockFilePackages(s *capnp.Segment) (LockFilePackages, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LockFilePackages(st), err
}

func NewRootLockFilePackages(s *capnp.Segment) (LockFilePackages, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return LockFilePackages(st), err
}

func ReadRootLockFilePackages(msg *capnp.Message) (LockFilePackages, error) {
	root, err := msg.Root()
	return LockFilePackages(root.Struct()), err
}

func (s LockFilePackages) String() string {
	str, _ := text.Marshal(0xb470b49a14912305, capnp.Struct(s))
	return str
}

func (s LockFilePackages) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (LockFilePackages) DecodeFromPtr(p capnp.Ptr) LockFilePackages {
	return LockFilePackages(capnp.Struct{}.DecodeFromPtr(p))
}

func (s LockFilePackages) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s LockFilePackages) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s LockFilePackages) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s LockFilePackages) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s LockFilePackages) Packages() (Package_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return Package_List(p.List()), err
}

func (s LockFilePackages) HasPackages() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s LockFilePackages) SetPackages(v Package_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewPackages sets the packages field to a newly
// allocated Package_List, preferring placement in s's segment.
func (s LockFilePackages) NewPackages(n int32) (Package_List, error) {
	l, err := NewPackage_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return Package_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// LockFilePackages_List is a list of LockFilePackages.
type LockFilePackages_List = capnp.StructList[LockFilePackages]

// NewLockFilePackages creates a new list of LockFilePackages.
func NewLockFilePackages_List(s *capnp.Segment, sz int32) (LockFilePackages_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[LockFilePackages](l), err
}

// LockFilePackages_Future is a wrapper for a LockFilePackages promised by a client call.
type LockFilePackages_Future struct{ *capnp.Future }

func (f LockFilePackages_Future) Struct() (LockFilePackages, error) {
	p, err := f.Future.Ptr()
	return LockFilePackages(p.Struct()), err
}

type Package capnp.Struct

// Package_TypeID is the unique identifier for the type Package.
const Package_TypeID = 0xc2d08935698f1b78

func NewPackage(s *capnp.Segment) (Package, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Package(st), err
}

func NewRootPackage(s *capnp.Segment) (Package, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2})
	return Package(st), err
}

func ReadRootPackage(msg *capnp.Message) (Package, error) {
	root, err := msg.Root()
	return Package(root.Struct()), err
}

func (s Package) String() string {
	str, _ := text.Marshal(0xc2d08935698f1b78, capnp.Struct(s))
	return str
}

func (s Package) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (Package) DecodeFromPtr(p capnp.Ptr) Package {
	return Package(capnp.Struct{}.DecodeFromPtr(p))
}

func (s Package) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s Package) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s Package) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s Package) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s Package) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s Package) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s Package) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s Package) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s Package) Version() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s Package) HasVersion() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s Package) VersionBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s Package) SetVersion(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

func (s Package) Found() bool {
	return capnp.Struct(s).Bit(0)
}

func (s Package) SetFound(v bool) {
	capnp.Struct(s).SetBit(0, v)
}

// Package_List is a list of Package.
type Package_List = capnp.StructList[Package]

// NewPackage creates a new list of Package.
func NewPackage_List(s *capnp.Segment, sz int32) (Package_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 8, PointerCount: 2}, sz)
	return capnp.StructList[Package](l), err
}

// Package_Future is a wrapper for a Package promised by a client call.
type Package_Future struct{ *capnp.Future }

func (f Package_Future) Struct() (Package, error) {
	p, err := f.Future.Ptr()
	return Package(p.Struct()), err
}

type FileHashes capnp.Struct

// FileHashes_TypeID is the unique identifier for the type FileHashes.
const FileHashes_TypeID = 0xed110dc172c21b8f

func NewFileHashes(s *capnp.Segment) (FileHashes, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FileHashes(st), err
}

func NewRootFileHashes(s *capnp.Segment) (FileHashes, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1})
	return FileHashes(st), err
}

func ReadRootFileHashes(msg *capnp.Message) (FileHashes, error) {
	root, err := msg.Root()
	return FileHashes(root.Struct()), err
}

func (s FileHashes) String() string {
	str, _ := text.Marshal(0xed110dc172c21b8f, capnp.Struct(s))
	return str
}

func (s FileHashes) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (FileHashes) DecodeFromPtr(p capnp.Ptr) FileHashes {
	return FileHashes(capnp.Struct{}.DecodeFromPtr(p))
}

func (s FileHashes) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s FileHashes) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s FileHashes) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s FileHashes) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s FileHashes) FileHashes() (FileHashes_Entry_List, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return FileHashes_Entry_List(p.List()), err
}

func (s FileHashes) HasFileHashes() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s FileHashes) SetFileHashes(v FileHashes_Entry_List) error {
	return capnp.Struct(s).SetPtr(0, v.ToPtr())
}

// NewFileHashes sets the fileHashes field to a newly
// allocated FileHashes_Entry_List, preferring placement in s's segment.
func (s FileHashes) NewFileHashes(n int32) (FileHashes_Entry_List, error) {
	l, err := NewFileHashes_Entry_List(capnp.Struct(s).Segment(), n)
	if err != nil {
		return FileHashes_Entry_List{}, err
	}
	err = capnp.Struct(s).SetPtr(0, l.ToPtr())
	return l, err
}

// FileHashes_List is a list of FileHashes.
type FileHashes_List = capnp.StructList[FileHashes]

// NewFileHashes creates a new list of FileHashes.
func NewFileHashes_List(s *capnp.Segment, sz int32) (FileHashes_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 1}, sz)
	return capnp.StructList[FileHashes](l), err
}

// FileHashes_Future is a wrapper for a FileHashes promised by a client call.
type FileHashes_Future struct{ *capnp.Future }

func (f FileHashes_Future) Struct() (FileHashes, error) {
	p, err := f.Future.Ptr()
	return FileHashes(p.Struct()), err
}

type FileHashes_Entry capnp.Struct

// FileHashes_Entry_TypeID is the unique identifier for the type FileHashes_Entry.
const FileHashes_Entry_TypeID = 0x8932f7433db89d99

func NewFileHashes_Entry(s *capnp.Segment) (FileHashes_Entry, error) {
	st, err := capnp.NewStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return FileHashes_Entry(st), err
}

func NewRootFileHashes_Entry(s *capnp.Segment) (FileHashes_Entry, error) {
	st, err := capnp.NewRootStruct(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2})
	return FileHashes_Entry(st), err
}

func ReadRootFileHashes_Entry(msg *capnp.Message) (FileHashes_Entry, error) {
	root, err := msg.Root()
	return FileHashes_Entry(root.Struct()), err
}

func (s FileHashes_Entry) String() string {
	str, _ := text.Marshal(0x8932f7433db89d99, capnp.Struct(s))
	return str
}

func (s FileHashes_Entry) EncodeAsPtr(seg *capnp.Segment) capnp.Ptr {
	return capnp.Struct(s).EncodeAsPtr(seg)
}

func (FileHashes_Entry) DecodeFromPtr(p capnp.Ptr) FileHashes_Entry {
	return FileHashes_Entry(capnp.Struct{}.DecodeFromPtr(p))
}

func (s FileHashes_Entry) ToPtr() capnp.Ptr {
	return capnp.Struct(s).ToPtr()
}
func (s FileHashes_Entry) IsValid() bool {
	return capnp.Struct(s).IsValid()
}

func (s FileHashes_Entry) Message() *capnp.Message {
	return capnp.Struct(s).Message()
}

func (s FileHashes_Entry) Segment() *capnp.Segment {
	return capnp.Struct(s).Segment()
}
func (s FileHashes_Entry) Key() (string, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.Text(), err
}

func (s FileHashes_Entry) HasKey() bool {
	return capnp.Struct(s).HasPtr(0)
}

func (s FileHashes_Entry) KeyBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(0)
	return p.TextBytes(), err
}

func (s FileHashes_Entry) SetKey(v string) error {
	return capnp.Struct(s).SetText(0, v)
}

func (s FileHashes_Entry) Value() (string, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.Text(), err
}

func (s FileHashes_Entry) HasValue() bool {
	return capnp.Struct(s).HasPtr(1)
}

func (s FileHashes_Entry) ValueBytes() ([]byte, error) {
	p, err := capnp.Struct(s).Ptr(1)
	return p.TextBytes(), err
}

func (s FileHashes_Entry) SetValue(v string) error {
	return capnp.Struct(s).SetText(1, v)
}

// FileHashes_Entry_List is a list of FileHashes_Entry.
type FileHashes_Entry_List = capnp.StructList[FileHashes_Entry]

// NewFileHashes_Entry creates a new list of FileHashes_Entry.
func NewFileHashes_Entry_List(s *capnp.Segment, sz int32) (FileHashes_Entry_List, error) {
	l, err := capnp.NewCompositeList(s, capnp.ObjectSize{DataSize: 0, PointerCount: 2}, sz)
	return capnp.StructList[FileHashes_Entry](l), err
}

// FileHashes_Entry_Future is a wrapper for a FileHashes_Entry promised by a client call.
type FileHashes_Entry_Future struct{ *capnp.Future }

func (f FileHashes_Entry_Future) Struct() (FileHashes_Entry, error) {
	p, err := f.Future.Ptr()
	return FileHashes_Entry(p.Struct()), err
}

const schema_e1dde60149aeb063 = "x\xda\xacV]l\x14U\x14\xfe\xce\xbd\xb3\xdd\xedv" +
	"\xebv3\xa3\xa8\x95\xd4 \x89`\x02)-\x10iB" +
	"\x0a\xa5\xc5VA:\x0ehl\xe0a\xd8\xdev\xd7\xae" +
	"3\xeb\xccniy\x10E\x1f\x80h\x08\x86\x07EH" +
	"\x94`b$Q\x1f0!&&@\xc2\x83&FH" +
	" &&\xa4!\x11\x83\x08\x89/(\x0f\x981g\xf6" +
	"o\xda*&\xeaS\xa7\xdf\xfd\xee9\xe7\x9e\xf3\x9ds" +
	"\xb6\xb3O\xae\xd3V\xb4~\xafA\x98O\xc6\x9a\x82\xf7" +
	"\x8e\x9d^\xbb\xe1\xf7\xae\xfd\xc8,\xa0\xe0`\xfb9\xef" +
	"lk\xe6\x16b\"\x0e\xe8\xa6\xb8\xa1\xef\x08\xbf^\x14" +
	"\xbb@\xc1\x03\xef\xff\xb6t\xe1\x813o#\xf3\x90\x08" +
	"\xa6\x7f\xbc\xfd\xec/G\x7f\xbd\x0aP\xf7\x17\"I\xfa" +
	"\xf9\x90yVl\x01\xcd\\:\x9f\xdd;\xd3w2\xd3" +
	".\x82S\x9d\xaf\xbe\xb0ou\xcb\x0d\xe6]\x16\x0f\x93" +
	"~-\xe4]e^\x10{\xec\x90q\xe4T\xf1\x142" +
	")\x0a\xb2\x9f\x7f:D?]\xb9\x8a\x181\xe3\xb6\xb8" +
	"\xa1\x93\xe4\xaf?D/(\x98j?\x98_\xb5\xff\xc2" +
	"9\x98)\x8a\x92Cs+\xe4q}MH^%?" +
	"\x03\xcd\x8c\x1f?y\xfd\xee\x1b\x97g\x9b\x0d\x99\xdf\xca" +
	"s\xfa\xe5\x90yQ\xf2\xa3\x86\xbe[\xdd\xbffm\xe1" +
	"\x0a2\xed\xd4\x086\xe4vo\xd3\x92\xa4+\x8d\xc9\xb6" +
	"\xc6\xe4\xfa\xa3\xe7\xc4\x90b\xcaW\xda7\xfa\xd7\xda\x02" +
	"\xa0\xfb\xa26#\x10\xb16\x87\x1dg\xf6P\xe2\x07}" +
	"[\xe2q\xa0;\x9f\x08\x08\x91\xe4\xffE.\xae$\xbf" +
	"\xd4\xaf%\x17\x00\xfa\xadd/\x96\x05E\xcf-\xb9\xcb" +
	"\xb3\xb6(:\xc5\x9e\x8d\xf9\x82\x1a\xb4\xfd\x9c\xf2\x97\x0f" +
	"\xa4\x9d\x927=Ld&\xa4\x06h\x04d\x96.\x02" +
	"\xcc\xc5\x92\xccNA\x19\"\x83\x18\\\xd6\x05\x98K$" +
	"\x99+\x05\xc5'\xd44\xa5 (\x05\xea\x98\xb4\x0be" +
	"U\xfb\xaf\xeeG\xb2\x9f\xad\xb6?\xc1~\xec\x9d\x05\xb5" +
	"|\xc0\x99\xdc\xec\x8e*\x80\x9d\xa5H\x00\x99\x85]\x00" +
	"Q\xe6~\xfe#2\xad=@G\xde\x19S^G\xc1" +
	"u}\xd5\xeb\x97\xbc|\xb64\xdb\xe4S\x05w\xa7]" +
	"\x98mT\x8e\xaa\x7fk3L\xc7&7;\xc1)\x19" +
	"\xb6\xb3\x13i{\\\xf9lM\xab\xa7\xa3\xf5i\xc0L" +
	"I2\x97\x08\x0a\x8avv\x82)\x00\xe8>\xd0\xb0$" +
	"jk\x08\x0d\xc4`\xdd:\xb1u\xb6\x1a\xb7\xc7+!" +
	"\xd6\x8d\x0ep\x8e\xd7I27Er<\xd4\x07\x98\xfd" +
	"\x92\xccaA$\x8c\xf0=\x9b9\xef\x83\x92\xcc\xad\xb3" +
	"\xf3\xbegRy~\xdeu\xeau\x18s\xcb\xce(\x11" +
	"\x04Q$\x04Q\xab\xc3\x96r\xa9X.\xf9\x98S\xea" +
	"\x91jU\xfb#a\xac\x1f\xa9\xc6\xb6]P\x90w\xb2" +
	"\x85\xb2\x9fw!\x1d\xbf\xf6bv\xc9\xefTS\x7f\x7f" +
	"v\xef\xaa\x95\xbci\xe0\xffW\x9d\x98\xab:\xc0\xd4(" +
	":\x87\xa8oOU\x88\xe6\xca\x9ak}\x07\x8d\x00\xd6" +
	"v\x92d\xe5\xa8\xe1]W\xf4\x09`\xe5\x18\x7f\x93q" +
	"Q\xa9\x89\xfez\xc8\x7f\x8d\xf1\xb7\x18\x97\xd2 \x09\xe8" +
	"\xfbi'`\xedc\xfc0\xe3\x9af\x90\x06\xe8\x87\xe8" +
	"\x00`\x1df\xfc\x03\xc6c1\x83b\x80~\x8c\x9e\x00" +
	"\xacw\x19?\xc1xS\x93AM\x80\xfe!\xf5\x01\xd6" +
	"Q\xc6?f<\x1e7\xc2\xa6\xfe\x88^\x02\xac\x13\x8c" +
	"\x9fa<\x910(\xc1s\x84\x16\x01\xd6i\xc6/1" +
	"\xde\xdclP3\xcf+\xda\x0bX\x17\x18\xbf\xc9x2" +
	"iP\x12\xd0\x7f\x0e\xe3\xbc\xce\xb8&\x04Q\x8bA-" +
	"\x80N\x82\xdd\xdee8!\x04eR-\x06\xa5\x00=" +
	"&z\x80\xe7\x84$\xeb\x11!(\x18\xaf\x16\x13\xd2\xcf" +
	"\xd5+P\xb2\xfd\x89~UT\xe4\x8c*';=h" +
	"\xa7y\xbc\xcc\x13E\xa5{\xfa!\xf3^\xfdj\xce\xf6" +
	"s[\xc66\xe6\x11/(\xbf\x8e\xaa\xa9\x92\xf2\x1c\xbb" +
	"@\xfd\xaa\xe8s9\x81\xdaY\x9a\x9d\xd5\xfb\xc0\xad\x08" +
	"\x9b\xdaj#\x1cDm\xa1/\xdf\xdf\x9a\xf3\xcaH\xaf" +
	"\xf7\xc6\xe7F\x12W\xce\xe4\xdc\xe0<\xe5\xbb\x85I5" +
	"J\x03\xce\xe4\xf3\xb6\xe7c~\xf4U\x8b\xf1\x81y\xb7" +
	"\xf7\xa8\x8a\xaa(\xdd\x10\x1b\x88\xd2\xa0\xdeQ\xb74\x9f" +
	"?[\xb2\xd1\xfe\x90\x05e&\xa8\xb1\x11\x9b\xfb\"\x1b" +
	"'\xd6U\x93oG\xd8D\xe6\xe2z\xff\xdc\xda\x0d\x98" +
	"7%\x99w\"\xfds\xfb\x1d\xc0\xbc#\xc92\xa2\xfa" +
	"\xcd\x84\xba6\xb8\xd0\x8fF\xf5\xbb0\xd4\xd1\x83\x8c\xaf" +
	"\x8c\xeawE\xa8\xa3N\xc67E\xf5;D\xbb\x01k" +
	"\x90\xf1Q\x12DU\xf9\xda\xa1|\x1b\xed\x14o\xab\xc8" +
	"W\xd1\x91Z;\x95B\xf96U\xe4\xfb\x0a\xf5\x00V" +
	"\x81\xf1}T\x17\xd8\x06\x1b\xbd\xd9\x9cz\xa6\xd1\xf4\xd5" +
	"\x83\x8dy\xaa\xac\xaf\xcd6\x15\x1bC\xb8\x9e\xa4\xea\x10" +
	"\xf6\\\xb740UR\xc4*b\x11\xa5\xf9N\xcd\xd6" +
	"\x7f\x11\x80\x8b\xde\xf2x\xee^\x1a\xa8\x15\xaf\xa2\x80`" +
	"\xcc\xb3_V\xbb\\\x8f&\x86x\x15)GfUm" +
	"R\xff\x83<\xa8\xb6\xaf{+\x0b;\x1cg\x8d\x9f`" +
	"\xd4U\xd5Ad]\x8dD\xd6\xd5Xu\xd3C6\x9a" +
	"\xb1\xadq\xbf\x92\xaa?\x03\x00\x00\xff\xff\x12\xd9E\xe5"

func RegisterSchema(reg *schemas.Registry) {
	reg.Register(&schemas.Schema{
		String: schema_e1dde60149aeb063,
		Nodes: []uint64{
			0x8932f7433db89d99,
			0x8dc08a1d29f69b16,
			0xab4200df8263c5d4,
			0xb470b49a14912305,
			0xc2d08935698f1b78,
			0xd58300fce8aba267,
			0xdd6c3d394436cf49,
			0xe1f09ceb4ef5e479,
			0xea0b3688577e30b4,
			0xed110dc172c21b8f,
		},
		Compressed: true,
	})
}
